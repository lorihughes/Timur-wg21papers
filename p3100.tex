\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Undefined behaviour is a contract violation}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
\\ Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net})  
% TODO: Is Gasper still in?  \\ Ga\v sper A\v zman \small(\href{mailto:gasper.azman@gmail.com}{gasper.azman@gmail.com})   \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3100R2 \\
Date: &2025-04-16 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
In this paper, we propose a generic framework for effective runtime mitigation of undefined behaviour in C++. We introduce \emph{implicit contract assertions}, which follow the same semantics as C++26 contract assertions \cite{P2900R14}, but are added implicitly by the compiler, rather than explicitly by the user. When a \emph{checked} semantic is chosen by the user, either via implementation-defined compile-time options or via in-code \emph{labels}, undefined behaviour is replaced by an implicit runtime check, followed by a call to the contract-violation handler and/or program termination.

We then proceed to apply the proposed framework holistically to the \emph{entire} C++ language. To this end, we enumerate all instances of undefined behaviour explicitly specified in the C++ language and systematically categorise them according to a number of important criteria. We then re-specify all such instances in terms of implicit contract assertions as appropriate for every such category.

This proposal represents a major step towards removing undefined behaviour from C++. It is intended as a contribution to the Core Language UB white paper \cite{P3656R0} currently in development.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*
\pagebreak

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

\subsection{Motivation}
\label{motivation}

Eliminating or at least meaningfully reducing the amount of unbounded \emph{undefined behaviour} is arguably the most critical objective for the future evolution of the C++ language. WG21 has been continuously working in that direction. For C++20, we removed an instance of undefined behaviour by introducing implicitly created objects \cite{P0593R6}; for C++23, by changing the semantics of temporaries in range-based for loops \cite{P2012R2}; for C++26, we gave defined behaviour to trivial infinite loops \cite{P2809R3} and certain cases\footnote{If the variable is default-initialised, of scalar type, and has automatic storage duration.} of reading uninitialised values.

While these improvements are certainly laudable, they are case-by-case fixes that do not meaningfully change the overall perception of C++ as an ``unsafe'' language.\footnote{See \cite{NSA2022}, \cite{CR2023}, \cite{CISA2023}, \cite{ONCD2024}; for replies by WG21 members see papers \cite{P2739R0}, \cite{P2759R1}, presentations \cite{Abrahams2023}, \cite{Bastien2023}, \cite{Carruth2023}, \cite{Doumler2023}, \cite{Parent2023}. A good contextualisation of the current discourse can be found in the article \cite{Sutter2024}. For recommendations regarding usage and meaning of the words ``safety'', ``safe'', and ``unsafe'' in this context, see \cite{P3500R1} and \cite{P3578R0}.} To move the needle, we need consensus on a \emph{holistic} and \emph{actionable} strategy for mitigating undefined behaviour systematically.

On the WG21 level, this consensus strategy does not yet exist. However, at the February 2025 meeting in Hagenberg, we at least agreed on a \emph{ship vehicle} for such a strategy: the \emph{Core Language UB white paper} \cite{P3656R0}, which we hope to draft and ship within the C++26 timeframe. This paper is intended as a direct contribution to that white paper.

Some constructs that have undefined behaviour in C++ today can in principle be mitigated \emph{statically} by subsetting the language, i.e., making ``unsafe'' constructs ill-formed or conditionally ill-formed; this approach is currently pursued in the Profiles proposal \cite{P3081R2}. Complementing the subsetting approach, new features that provide a ``safer'' alternative can be added; a notable example is Sean Baxter's work on adding borrow checking to C++ \cite{P3390R0}.

While this ``superset of a subset'' approach is promising for newly written code, it is not backwards-compatible with existing code. This is because undefined behaviour is fundamentally a \emph{run-time} property. For most language constructs in C++, it is unknowable until run time whether they will have defined behaviour, because this depends on run-time values. If we were to reject all ``unsafe'' constructs at compile time, we would inevitably also reject vast swathes of existing code that is well-formed and has well-defined behaviour today.

Instead, most existing instances of undefined behaviour in C++ need to be mitigated at run time. We need to retroactively \emph{define} the behaviour of existing instances of undefined behaviour in some way that is backwards-compatible with existing source code, run-time behaviour, and performance characteristics. This is the problem our paper addresses.

\subsection{Outline}

In this paper, we propose a generic framework for run-time mitigation of undefined behaviour that can be applied across the entire C++ language. Our proposal does not compete with proposals that follow the ``superset of a subset'' strategy, but rather \emph{complements} them by addressing all the undefined behaviour that cannot be addressed by that strategy.

Our proposed framework rests on two key ideas: the systematic introduction of \emph{run-time checks} guarding against run-time undefined behaviour and, where possible, the systematic replacement of undefined behaviour with \emph{fallback behaviour} that is erroneous but well-defined. The design of our framework builds on top of the foundations we laid in C++26: contract assertions \cite{P2900R14} and erroneous behaviour \cite{P2795R5}. 

In Section~\ref{ub}, we begin by enumerating \emph{all} instances of core undefined behaviour that exist in C++ today. We proceed to classify them according to a number of criteria to determine how and to what extent our framework can be applied to each one, and to get a sense of the associated complexity and cost. 

In Section~\ref{otherdefects}, we consider manifestations of program defects other than run-time undefined behaviour, such as erroneous behaviour, IFNDR, and program termination, and discuss whether and how they relate to our framework.

In Section~\ref{design}, we describe the design of our framework. We introduce the notion of \emph{implicit contract assertions}, with the same evaluation semantics as the explicit contract assertions introduced by \cite{P2900R14}, but inserted implicitly by the compiler rather than explicitly by the user. We describe a generic method to specify such insertions for any kind of undefined behaviour in C++. To enable well-defined fallback behaviour after a failed implicit contract assertion, we generalise the concept of \emph{erroneous behaviour} and integrate it into our framework. Further, we discuss how the evaluation semantics of implicit contract assertions can be controlled in-code with arbitrary granularity using \emph{labels} (\cite{P3400R1}). We discuss the possible addition of a fifth evaluation semantic to the existing set of four (\emph{ignore}, \emph{observe}, \emph{enforce}, and \emph{quick-enforce}) as a tool for avoiding performance regressions. Finally, we cover the required additions to the standard library API for contract-violation handling to accommodate implicit contract assertions.

In Section~\ref{application}, we put everything together into a concrete, actionable proposal by applying our framework to specific instances of undefined behaviour that exist in C++ today. We identify a set of cases for which this can be done immediately with obvious gain and relatively little effort. We describe the assertions and fallback behaviour that need to be inserted for those cases, possible implementation strategies, and the resulting overhead. We discuss the meaning of the available evaluation semantics for these cases and how they map to existing mitigation strategies in compilers and sanitisers. Draft wording for this proposal is provided in In Section~\ref{wording}.

We conclude by outlining in Section~\ref{extensions} how future extensions of the present proposal will cover the remaining cases.

\subsection{History}
\label{history}

The first revision (R0) of this paper was published in May 2024. Following informal discussions at the St. Louis meeting, the paper was revised (R1) and presented to SG21 (Contracts study group) at the Wroc{\l}aw meeting. SG21 voted \emph{unanimously} in favour of our direction:
\vspace{2mm}
\begin{wgpoll}{{SG21 Poll 6, Wroc{\l}aw, 2024-11-22}}
We support the direction of P3100R1 and encourage the authors to come back with a fully specified proposal.
\wgpollresult{19}{6}{0}{0}{0}
Result: Consensus
\end{wgpoll}
\vspace{2mm}

The present revision (R2) takes into account the above poll, the adoption of \cite{P2900R14} into the C++26 working paper, the decision to publish the white paper \cite{P3656R0}, and other progress made at the Hagenberg meeting.

\subsection{Related work}

Our paper overlaps with a number of Profiles-related papers. In addition to specifying a subset of the language that statically removes certain ``unsafe'' constructs, \cite{P3081R2} also proposes runtime checks guarding against out-of-bounds array access, null pointer dereference, and arithmetic overflow. \cite{P3436R1} is a strategy paper from the same author sketching a strategy for removing undefined behaviour from C++ which is similar in spirit to our paper.

However, the important distinction is that  \cite{P3081R2} and \cite{P3436R1} tie the control of such implicit runtime checks to Profiles. In \cite{P3543R0} and \cite{P3558R1}, we and others recommend to limit Profiles to  subsetting the language. The natural paradigm for \emph{run-time} mitigation of program defects is Contracts; insertion and control of implicit runtime checks should therefore be realised within a framework based on that paradigm. This paper is proposing that framework.

Further, our paper has overlap with other papers that build on erroneous behaviour as proposed in \cite{P2795R5} and added to the C++26 working paper, such as \cite{P2973R0} and \cite{P3232R1}. In order to realise the framework proposed here, we need to slightly modify the specification of erroneous behaviour and effectively absorb that notion into the concept of implicit contract assertions (see Section~\ref{eb}). These modifications impact those proposals and potentially renders them obsolete.

Finally, our paper also relates to --- and proposes a solution for --- another much-discussed issue: the fact that \emph{explicit} contract assertions in C++26, as specified in \cite{P2900R14}, can themselves have undefined behaviour when checked, because explicit contract assertion predicates are boolean expressions and thus follow the usual rules for evaluating expressions in C++. This property has been repeatedly raised as a concern (see \cite{P2680R1}, \cite{P3173R0}, \cite{P3285R0}, and \cite{P3362R0}).

The approach suggested in those papers is to constrain contract assertion predicates to expressions that can be statically proven to have no undefined behaviour. However, this approach does not seem to be specifiable, implementable, or usable in practice (see  \cite{P3376R0}, \cite{P3386R0}, and \cite{P3499R1}) and has thus been rejected by WG21. What \emph{does} work to solve this problem is to specify a framework for mitigating undefined behaviour across the \emph{entire} core language specification. It will then automatically also apply to contract assertion predicates. This paper is that framework.

\section{Undefined behaviour}
\label{ub}

\subsection{Enumeration}

\subsubsection{Methodology}

For this paper, we manually inspected all occurrences of the word ``undefined'' in the current C++ working paper \cite{N5008}. We then constructed a list of all instances of explicitly specified core language undefined behaviour in C++. The complete list can be found in Appendix~A of this paper. % TODO: add \ref to appendix
It contains a total of 84 entries. % TODO: The weird library one is the 85th, count it or not?

Note that we deliberately did not add stable identifiers to these entries and instead gave them alphanumeric indices. This is because separately from our work, there is an ongoing effort in WG21 to add an Annex to the C++ Standard that enumerates all instances of undefined behaviour and IFNDR, based on Shafik Yaghmour's work \cite{P3075R0}. This effort assigns stable identifiers, based on the identifier of the affected subclause, to those instances.

We found Shafik's list to be incomplete and contain some inaccuracies at the time of writing, so we are using our own list for now. However, we are currently contributing to their work to merge the two lists; once complete, we expect to rebase this paper onto the merged list and use their stable identifiers.

\subsubsection{Core vs. library undefined behaviour}

Sometimes, an informal distinction is made between \emph{core} undefined behaviour (sometimes also called ``language'' undefined behaviour or ``hard'' undefined behaviour) and \emph{library} undefined behaviour (sometimes also called ``soft'' undefined behaviour). The C++ Standard itself does not distinguish between those terms: according to the Standard, an operation simply either has undefined behaviour when executed or it does not.

Library undefined behaviour is informally understood to mean the violation of a (plain-language) contract of a user-defined function (for example, an out-of-bounds call to the \tcode{operator[]} of a vector-like class). Once that function is called out-of-contract, the author of that function makes no guarantees regarding the behaviour of the program. 

By contrast, core undefined behaviour occurs when the evaluation of a core language construct has undefined behaviour according to the C++ Standard (out-ouf-bounds access into a plain array, arithmetic overflow, etc.). Library undefined behaviour may or may not subsequently lead to core undefined behaviour when execution continues into the function; whether it does depends on the implementation of the function.

A special case is the violation of a precondition of a standard library function (for example, an out-of-bounds call to \mbox{\tcode{std::vector::operator[]}}). The C++ Standard specifies that such a violation is undefined behaviour (in the same way as core undefined behaviour). While some compilers may take advantage of this leeway to enable additional optimisations on standard library function calls, in most cases the violation of a standard library precondition will in practice behave like library undefined behaviour.

The tool of choice for mitigating library undefined behaviour in user code are explicit contract assertions as specified in \cite{P2900R14}. Specifically for standard library preconditions, our mitigation strategy is library hardening \cite{P3471R4}, which builds on top of \cite{P2900R14}. In this paper, we therefore focus exclusively on core undefined behaviour. Therefore, Appendix A takes into account only undefined behaviour listed in Clauses 1 --- 15 of the C++ Standard.
  
\subsubsection{Explicit vs. implicit undefined behaviour}

We can further distinguish between \emph{explicit} and \emph{implicit} undefined behaviour. Explicit undefined behaviour is undefined behaviour called out as such in the C++ Standard, while implicit undefined behaviour is undefined behaviour by omission: a situation where an operation is well-formed but the Standard fails to describe what behaviour it has when executed.

Arguably, all instances of implicit undefined behaviour are nothing other than specification bugs. Whenever one such instance is found, it should be treated as a Core issue and fixed, although admittedly we can never be sure we found all of them. While the existence of implicit undefined behaviour is an issue, we do not target it in this paper, and instead focus exclusively on explicit undefined behaviour. 

\subsection{Classification}

\subsubsection{Categories of undefined behaviour}

We found that all instances of undefined behaviour in the core language can be broadly classified into one of the following  categories:
\begin{itemize}
\item \textbf{Type and Lifetime (TL)} --- 45 instances. Operations that access storage and/or use pointers or references to storage in a way that is  inappropriate for the type that either does not contain an object within its lifetime or is associated with an object of incompatible type. Examples: 
TODO
\item \textbf{Bounds (B)} --- 5 instances. Using a pointer in a way that is incompatible with the range of the pointed-to object or array. Examples: incrementing a pointer beyond the past-the-end position; performing single-object delete on an operand obtained from an array-new expression;  dereferencing a pointer returned from a request for zero size.
\item \textbf{Initialization (IN)} --- 1 instance. Evaluating an expression that produces an indeterminate value.
\item \textbf{Arithmetic (AR)} --- 9 instances. Executing an arithmetic operation whose operands fail to meet certain preconditions. Examples: division by zero; conversion of a value to a different arithmetic type that cannot represent that value. 
\item \textbf{Threading (TH)} --- 1 instance. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from different threads where neither access happens-before the other.
\item \textbf{Sequencing (SQ)} --- 1 instance. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from the same thread where neither access is sequenced before the other.
\item \textbf{Control flow (CF)} --- 6 instances. Examples: flowing off the end of a function; re-entering the same declaration recursively when initialising a static variable.
\item \textbf{Coroutines (CR)} --- 2 instances. Misusing coroutine machinery. Destroying a coroutine that is not suspended; invoking a resumption member function for a coroutine that is not suspended.
%\item \textbf{Standard library (SL)} --- 1 instance. Using a standard library object or function not permitted within signal handlers after destruction of objects with static storage duration and execution of \tcode{std::atexit} registered functions. % TODO: this is actually library UB, isn't it? Leaving it off for now, but need to explain that somewhere
\item \textbf{Replacement functions (RF)} --- 3 instances. Executing a user-defined replacement function (\tcode{operator new}/\tcode{delete}) that fails to meet the specified requirements. Examples: returning \tcode{null} from a user-defined placement \tcode{new}; throwing an exception from a user-defined \tcode{delete}.
\item \textbf{Compilation failures (CF)} --- 1 instance. Infinite recursion during template instantiation.
\item \textbf{Preprocessor (PP)} --- 8 instances. Misusing preprocessor directives. Examples: \tcode{\#define}-ing a predefined macro name; passing an out-of-range integer to the \tcode{\#line} directive.
\end{itemize}

The first three categories represent undefined behaviour that is commonly referred to under the umbrella term ``memory safety''. This is often broken down into ``type safety'',  ``lifetime safety'', ``bounds safety'', and ``initialisation safety'', which correspond to our categories TL, B, and IN, respectively.

Note that we grouped ``type safety'' and ``lifetime safety'' into a single combined category TL. Of course there are instances of undefined behaviour that are primarily caused by type aliasing, and others that are primarily caused by out-of-lifetime accesses. However, it is evident from the list that they form a spectrum rather than a hard boundary. Many common operations in C++ (e.g., using a reference) rely on \emph{both} type and lifetime constraints to be satisfied. Remarkably, our combined TL category contains more instances of undefined behaviour than all the other categories taken together.

The next categories, AR, and TH, correspond to the terms ``arithmetic safety'' and ``thread safety'', respectively. It might seem surprising at first that we grouped threading and sequencing into two separate categories as their specification has a very similar same shape (except that one is inter-thread and the other is intra-thread). However, as we will see in Section~\ref{TODO}, these two categories actually require very different approaches to mitigation.

The final five categories of undefined behaviour (CF, CR, RF, CF, and PP) are much less frequently discussed but they nevertheless need to be mitigated so we cover them in this paper.

\subsubsection{Is runtime mitigation needed?}

Undefined behaviour is inherently a run-time property. However, if the compiler can reason \emph{at compile time} that a given operation will \emph{always} result in undefined behaviour, there is no need to detect the undefined behaviour at runtime, and in fact no benefit in specifying that operation as undefined behaviour at all. This concerns all items in categories CF and PP as well as a few other cases.

Infinite recursion during template instantiation (the only item in category CF) is inherently a compile-time error and we see no reason to specify it to be (run-time) undefined behaviour. We can simply specify that infinite recursion during template instantiation renders the program ill-formed. Arguably, all existing implementations are already conforming with such a specification because infinite recursion during template instantiation causes the compiler to error out in one way or another. This fix will be proposed separately as a Core issue.

Similarly, failures at the preprocessor stage (category PP) can be caught at that stage and there is no reason for them to cause run-time undefined behaviour. This fix is already being proposed in \cite{P2843R0}.

Further, RF3 specifies that if a user-defined \tcode{operator delete} terminates by throwing an exception, the behaviour is undefined. However, ... TODO % TODO isn't a user-defined operator delete always noexcept? How can this happen?
% TODO: aren't CR and the other RF's also like this?

Finally, TL45 specifies that ``the invocation of a destructor is subject to the usual rules for member functions ([class.mfct]); that is, if the object is not of the destructor's class type and not of a class derived from the destructor's class type (including when the destructor is invoked via a null pointer value), the program has undefined behaviour''. This item does not in fact introduce another instance of undefined behaviour, but merely refers to an existing one in [class.mfct]. Arguably, this whole sentence should therefore be just a non-normative note. This fix will be proposed separately as a Core issue.

Since the instances of undefined behaviour called out in this section can be handled normatively for all cases without the need for run-time mitigation and without any backwards-compatibility concerns, we do not consider them further in this paper.

\subsubsection{How hard to check?}
% TODO: locally checkable?

All remaining instances of undefined behaviour only occur under certain conditions that are not known until run time. An important way to classify them is to ask the question how \emph{hard} it is for a compiler to insert a run-time check that the condition in question has, in fact, occurred.

As a first approximation, we can distinguish between checks that can be performed within the C++ abstract machine and checks that require additional instrumentation. The former can be further subdivided into whether such a check can be expressed as a simple boolean expression (much like an explicit contract assertion) % TODO: we have not mentioned assertions yet at this point! That's important context though
or whether it would have to be implemented via ``compiler magic''. The latter can be distinguished by the kind of instrumentation required to construct the check; in particular, which properties (object lifetimes, etc.) would have to be tracked by such instrumentation.

TODO 

\subsubsection{How expensive to check?}


\subsubsection{How hard it is to check?}


\section{Other manifestations of program defects}
\label{otherdefects},

\subsection{Erroneous behaviour}
\label{eb}

TODO MERGE P3229 HERE


\subsection{IFNDR}

IFNDR (``Ill-formed, no diagnostic required'') is very similar in nature to undefined behaviour. In particular, just like for programs that exhibit undefined behaviour, the C++ Standard does not place any requirement on the behaviour of a program that is IFNDR.

However, while undefined behaviour is fundamentally a run-time property, IFNDR is a \emph{static} property. In general, IFNDR cannot be diagnosed at compile time (often, it relates to inconsistencies between translation units), but in some cases it may lead to a linker error instead. In any case, since IFNDR is a static property, and this paper focuses on run-time mitigation, IFNDR is out of scope for this paper.

\subsection{Termination}

Cite Gasper's paper here

\subsection{Other}

TODO FLESH OUT

%TODO OTHER STUFF  IN SUBSECTIONS HERE

\section{Design}
\label{design}

TODO
]

\section{Application}
\label{application}


\section{Proposed wording}
\label{wording}

\section{Future extensions}
\label{extensions}


TODO

\section*{Document history}
\begin{itemize}
\item \textbf{R0}, 2023-03-08: Initial version.
\item \textbf{R1}, 2024-10-16: Complete rewrite after the WG21 meeting in St. Louis.
\item \textbf{R2}, 2025-04-16: Complete rewrite after the WG21 meeting in Hagenberg and the addition of \cite{P2900R14} into the C++26 working paper.
\end{itemize}

\section*{Acknowledgements}

We wish to thank Herb Sutter, Oliver Rosten, Andrzej Krzemie\' nski, and Roger Orr for their helpful feedback on a previous revision of this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

