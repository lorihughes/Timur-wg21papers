\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Implicit contract assertions}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
\\ Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net})  
% TODO: Is Gasper still in?  \\ Ga\v sper A\v zman \small(\href{mailto:gasper.azman@gmail.com}{gasper.azman@gmail.com})   \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P3100R2 \\
Date: &2025-05-19 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
This paper is a proposed additon to the core language UB white paper \cite{P3656R1}. We enumerate all explicitly specified cases of language UB in C++, group them into categories, and classify them along a number of relevant criteria. We discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checks are an appropriate strategy for the majority of cases. We propose to systematically introduce such runtime checks to the C++ Standard via \emph{implicit contract assertions}, building on the Contracts framework adopted for C++26. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

Eliminating or at least meaningfully reducing the amount of unbounded \emph{undefined behaviour} (UB) is a critically important objective for improving ``safety''\footnote{In this paper, we never use the term ``safety'' unqualified except in quotes because of the crucial importance to distinguish between different conflicting definitions of that term, such as functional safety and language safety.  See \cite{P3500R1} and \cite{P3578R0} for a discussion of those definitions and recommendations regarding usage of the term ``safety'' in the context of C++.}
and security for the future evolution of the C++ language. WG21 has been continuously working in that direction (for a recent status update, see \cite{Sutter2025} and references therein; for background, see \cite{Sutter2024} and references therein).

At the February 2025 WG21 meeting in Hagenberg, EWG agreed on a framework for a systematic
treatment of core language undefined behaviour in C++: the pursuit of a core language UB white paper in the C++26 timeframe, covering Erroneous Behaviour, Profiles, and Contracts. The current version of that white paper is \cite{P3656R1}, proposing the process and major work items. The proposed process calls for papers to be adopted into the white paper working draft via EWG approval. This is the first such paper.

Further, as major work items, \cite{P3656R1} proposes to enumerate and group all language UB in C++, identify tools to address them, and take a first pass at penciling in which tool to use for each UB case. The goal of this paper is to contribute to all of the above major work items.

In Section~\ref{ub}, we identify and enumerate all language UB explicitly specified in the C++ Standard. We then group all language UB into broad categories such as ``Arithmetic'' and ``Bounds''. We then classify cases of UB along several relevant criteria: whether they are locally diagnosable, how expensive that diagnosis is, and whether there is well-defined fallback behaviour for each case. Finally, we discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checking is an appropriate strategy for the large majority of cases.

In Section~\ref{design}, we focus on systematically introducing runtime checks for UB detection and mitigation. We propose to implement them via the introduction of \emph{implicit contract assertions} to C++, building on the basic Contracts framework adopted for C++26 via \cite{P2900R14}. We describe how such implicit contract assertions should be specified and how to apply them to all appropriate cases of language UB. For cases of UB where well-defined fallback behaviour exists, we discuss how specifying it allows the program to continue execution past a violated implicit contract assertion without UB. We conclude by proposing an escape hatch to mitigate the runtime cost of such fallback behaviour and avoid performance regressions.

In Section~\ref{wording}, we propose wording for the design in Section~\ref{design} for approval into the white paper.

The first revision (R0) of this paper was published in May 2024. Following informal discussions at the St. Louis meeting, the paper was revised (R1) and presented to SG21 at the Wroc{\l}aw meeting. SG21 voted \emph{unanimously} in favour of our direction for implicit contract assertions:
\vspace{2mm}
\begin{wgpoll}{{SG21 Poll 6, Wroc{\l}aw, 2024-11-22}}
We support the direction of P3100R1 and encourage the authors to come back with a fully specified proposal.
\wgpollresult{19}{6}{0}{0}{0}
Result: Consensus
\end{wgpoll}
\vspace{2mm}

The present revision (R2) is a complete rewrite of the paper that takes into account the above poll, the adoption of \cite{P2900R14} into the C++26 working paper, EWG's decision to publish the core language UB white paper, and the current state of that white paper \cite{P3656R1}.

\section{Enumerating and grouping core language UB}
\label{ub}

\subsection{Methodology and scope}

For this paper, we manually inspected all occurrences of the word ``undefined'' in the current C++ working paper \cite{N5008}. We then constructed a list of all cases of explicitly specified language UB. Our complete list, containing 83 cases of UB, can be found in Appendix~A of this paper. % TODO: add \ref to appendix

We compiled our list independently from another, ongoing effort by a group of WG21 members to enumerate cases of language UB directly in the C++ Standard document  \LaTeX{} source, based on work by Shafik Yaghmour (\cite{P1705R1}, \cite{P3075R0}) and following the process outlined in \cite{P3656R1}. Wherever possible, we use the same stable identifiers for our own list as the \LaTeX-based list does, although we identified a number of defects and omissions in Shafik's list as well as some other differences between the two lists. We are actively contributing to the \LaTeX-based effort to merge the two lists. 

Note that unlike the \LaTeX-based effort, our list excludes cases of IFNDR, as we focus on runtime checking as a mitigation strategy. While UB is fundamentally a runtime property of a particular program execution, and thus runtime checking is a natural mitigation approach, IFNDR typically represents link-time issues and is therefore out of scope for this paper.

Note further that we exclude \emph{library undefined behaviour}, as the natural mitigation approach for it is library hardening \cite{P3471R4}, which is likewise out of scope for this paper. We therefore only take into account UB is specified in the core language part of the C++ Standard (Clauses 1 --- 15). Further, we found one case of UB that is specified in the core language part of the C++ Standard but actually represents a precondition on C++ Standard library functions;\footnote{\textbf{[basic.start.term]/6}: If there is a use of a standard library object or function not permitted within signal handlers ([support.runtime]) that does not happen before ([intro.multithread]) completion of destruction of objects with static storage duration and execution of \tcode{std::atexit} registered functions ([support.start.term]), the program has undefined behavior.}
that case is also not considered in this paper.

\subsection{Categories}

We found that all identified cases of language UB in the core language can be broadly classified into one of the following basic categories:
\begin{itemize}
\item \textbf{Initialisation} --- 1 case. Evaluating an expression that produces an indeterminate value.
\item \textbf{Bounds} --- 5 cases. Using a pointer in a way that fails to respect the range of the pointed-to object or array. Examples: incrementing a pointer beyond the past-the-end position; performing single-object delete on an operand obtained from an array-new expression;  dereferencing a pointer returned from a request for zero size.
\item \textbf{Type and Lifetime} --- 45 cases. Operations that access storage and/or use pointers or references to storage in an inappropriate way that is not already covered by Initialisation and Bounds. Examples: attempting to access a value of one type through  a pointer of a different, incompatible type; attempting to access the value of an object after its lifetime has ended. 
\item \textbf{Arithmetic} --- 9 cases. Executing an arithmetic operation whose operands fail to meet certain preconditions. Examples: division by zero; conversion of a value to a different arithmetic type that cannot represent that value. 
\item \textbf{Threading} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from different threads where neither access happens-before the other.
\item \textbf{Sequencing} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from the same thread where neither access is sequenced before the other.
\item \textbf{Assumptions} --- 1 case. Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}.
\item \textbf{Control flow} --- 6 cases. Examples: flowing off the end of a function; re-entering the same declaration recursively when initialising a static variable.
\item \textbf{Replacement functions} --- 3 cases. Executing a user-defined replacement function (\tcode{operator new}/\tcode{delete}) that fails to meet the specified requirements. Examples: returning \tcode{null} from a user-defined placement \tcode{new}; throwing an exception from a user-defined \tcode{delete}.
\item \textbf{Coroutines} --- 2 cases. Misusing coroutine machinery. Destroying a coroutine that is not suspended; invoking a resumption member function for a coroutine that is not suspended.
\item \textbf{Compilation} --- 1 case. Infinite recursion during template instantiation.
\item \textbf{Preprocessor} --- 8 cases. Misusing preprocessor directives. Examples: \tcode{\#define}-ing a predefined macro name; passing an out-of-range integer to the \tcode{\#line} directive.
\end{itemize}

The categories Initialisation, Bounds, Type and Lifetime correspond to the common terms  ``initialisation safety'',  ``bounds safety'', ``type safety'',  and ``lifetime safety'', respectively, and collectively represent undefined behaviour that is commonly referred to with the umbrella term ``memory safety''. 

Note that we grouped ``type safety'' and ``lifetime safety'' into a single combined category Type and Lifetime. This is because it is often impossible to unambiguously categorise a particular case of UB into one or the other bucket as it concerns both. While there are cases of UB that are primarily caused by type aliasing, and others that are primarily caused by out-of-lifetime accesses, they form a spectrum, and many common operations in C++ (e.g., using a reference) rely on \emph{both} type and lifetime constraints to be satisfied. Note further that this combined category Type and Lifetime contains the majority (54\%) of all cases of UB that we identified.

The next two categories, Arithmeric and Threading, correspond to the common terms ``arithmetic safety'' and ``thread safety'', respectively.

The following category, Sequencing, contains just one case of UB: unsequenced operations such as \mbox{\tcode{i++ + ++i}}. It might seem surprising at first that we grouped threading and sequencing into two separate categories as their specification has a very similar same shape (except that one is inter-thread and the other is intra-thread). However, as we will see in Section~\ref{mitigation}, these two categories actually require very different approaches to mitigation.

The next category, Assumptions, also contains just one case of UB: Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}. As we will see in Section~\ref{mitigation}, this case of UB is of a different nature than the others and warrants its own category.

The final five categories (Control flow, Replacement functions, Coroutines, Compilation failures, and Preprocessor) are much less frequently discussed in the current discourse around UB. Nevertheless, they represent UB that needs to be mitigated somehow.

\subsection{Security-related?}

\cite{P3656R1} asks the question which cases of UB are security-related. The paper suggests to have security experts tag which cases of UB have security impact always, never, or sometimes. As we are not security experts, we do not attempt to do this here. However, we will note that cases of UB commonly associated with security vulnerabilities (see for example the CWE list at \url{https://cwe.mitre.org/}) fall into the categories Initialisation, Bounds, Type and Lifetime. 

Other cases of UB, such as those in categories Arithmetic and Threading, are a common source of program defects, and those program defects do sizeable damage to existing software, so there is a lot of value in mitigating them, but to our knowledge they are not commonly exploited by malicious attackers.

\subsection{Locally diagnosable?}
\label{locally}

The second question that \cite{P3656R1} asks is which cases of UB are ``efficiently locally diagnosable''. Here, we break this down into two separate questions: which cases of UB are known to be locally diagnosable (this subsection), and what the cost of diagnosis is (next subsection).

Most cases in the Initialisation, Bounds, Type and Lifetime categories are \emph{not} locally diagnosable. 

From the Bounds category, 
\{expr.add.out.of.bounds\} 
and \{expr.add.sub.diff.pointers\} 
are partially locally diagnosable (only if the array bound is statically known).

From the Type and Lifetime category,
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}
are partially locally diagnosable (for the null pointer case).
\{expr.mptr.oper.member.func.null\} is locally diagnosable because this case requires \emph{only} a null pointer check.
\{basic.align.object.alignment\} is locally diagnosable by checking the alignment of storage when creating an object at runtime.
\{expr.assign.overlap\} is locally diagnosable by checking the overlap of the two address ranges (the ranges are known because the address and \tcode{sizeof} are known at runtime for both the source and the destination object). \{class.abstract.pure.virtual\} is locally diagnosable by adding a runtime check to  the pure virtual function stub that the base class vtable points to.

All other cases of UB in the Initialisation, Bounds, Type and Lifetime categories require additional instrumentation to be diagnosable, of the kind that is implemented in sanitisers such as ASan and UBSan (see also Section~\ref{cost}).

All cases of UB in the Arithmetic category are locally diagnosable as they are all cases of an arithmetic operation producing a value that is somehow inappropriate (mathematically invalid, not representable in the target type, etc.) and that value can be inspected at runtime.

UB in the Threading category is not locally diagnosable, but UB in the Sequencing category is. 

UB in the Assumption category is in principle locally diagnosable by evaluating the operand of the assumption and checking whether the resulting value, contextually converted to \tcode{bool}, equals \tcode{true}. However, if that evaluation has any side effects, the check could alter the observable state of the program. This means that even if the given assumption holds and there is no UB, the check itself might render the program invalid by altering its state. Therefore, this UB is only meaningfully diagnosable at all in any automated fashion if the operand has no side effects when evaluated. However, proving that the operand has no side effects is in general not possible either (Halting problem). 

Some cases of UB in the Control Flow category are locally diagnosable. \{stmt.return.flow.off\} and \{stmt.return.coroutine.flow.off\} can be diagnosed by inserting a check at the end of every function body that does not end with a \tcode{return} or \tcode{co_return} statement. \{dcl.attr.noreturn.eventually.returns\} can be diagnosed by inserting a check into every function declared \tcode{[[noreturn]]}

Some cases of UB in the Replacement Function category are partially or fully locally diagnosable. In particular, some of the constraints specified in \{basic.stc.alloc.dealloc.constraint\} and \{expr.new.non.allocating.null\} are locally diagnosable, while others are not. In particular, it is possible to check locally that a deallocation function does not exit via an exception, and that an allocation function does not return null. However, is not possible to check the other constraints (locally or at all).

All cases of UB in the Coroutine category are not locally diagnosable. 

All cases of UB in the Compilation and Preprocessor categories are diagnosable at compile time (see also Section~\ref{mitigation}).

\subsection{Cost of diagnosis}
\label{cost}

To estimate the cost of diagnosis, it is useful to consider locally diagnosable and not locally diagnosable cases of UB separately. Note that in this paper, we study the theoretical, relative cost based on the current specification of the C++ language, however we do not measure the actual cost of diagnosis in real implementations and we do not present benchmarks; this is left for future studies.

\subsubsection{Locally diagnosable}

For locally diagnosable cases, there is always some kind of runtime check --- an \emph{assertion} --- that could be inserted by the implementation and then evaluated at runtime. The total cost of diagnosis is therefore equal to the cost of evaluating that check multiplied by the number of times the check needs to be evaluated.

The cheapest kind of check, and the only one that has no overhead for the happy case, is the ``fail if you get here'' check --- effectively a \tcode{pre}/\tcode{post}/\tcode{contract_assert(false)}. This kind of check is sufficient to diagnose \{class.abstract.pure.virtual\}, \{stmt.return.flow.off\}, \{stmt.return.coroutine.flow.off\}, and \{dcl.attr.noreturn.eventually.returns\}.

A slightly more expensive, but still cheap and optimiser-friendly kind of check is a null check, required to diagnose the null pointer cases  
(
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}, 
\{expr.mptr.oper.member.func.null\}, and
\{expr.new.non.allocating.null\}
) as well as division by zero (\{expr.mul.div.by.zero\}).

Similarly cheap and optimiser-friendly are integer comparisons. These are  required for bounds checks with statically known array bounds
(
\{expr.add.out.of.bounds\},
\{expr.add.sub.diff.pointers\}
), as well as for \{expr.shift.neg.and.width\} and for \{intro.execution.unsequenced.modification\}.

Beyond this, there are a number of UB cases that can still be checked by a straightforward arithmetic expression, but with increasingly expensive expressions: \{expr.assign.overlap\} requires computing whether two integer ranges overlap, and  \{basic.align.object.alignment\} requires computing an integer modulo. 

At the expensive end of this spectrum lie runtime checks for which there is no corresponding C++ expression; instead the compiler would have to generate elaborate ``magic'' checks based on knowledge not available in the C++ abstract machine. In particular, this is the case for all arithmetic UB except \{expr.add.out.of.bounds\} and
\{expr.add.sub.diff.pointers\}. The compiler would have to validate the bit patterns of values of arithmetic types according to knowledge it has about how values of such types are represented on the given platform. Such checks can be done locally, but they can make operations involving built-in types and in particular floating-point types very slow.

In addition to the cost of the check itself, we need to consider the frequency with which these checks would need to be done. Checks that would need to happen once when a function is called or when a function returns are likely to be acceptable in most scenarios. Extensive checks for arithmetic UB will probably be acceptable in fewer scenarios because they would significantly slow down arithmetic operations, which are performance-sensitive in many contexts. On the extreme end, if we wanted to diagnose \{intro.execution.unsequenced.modification\} via a runtime check, the check in itself would not be very expensive but the compiler would have to put this check on every possible pair of unsequenced operations everywhere, which can lead to a combinatorial explosion for complex expressions.
% TODO: Is this last statement actually true? I'm not sure.
\subsubsection{Not locally diagnosable}

As we saw in Section~\ref{locally}, most cases of UB are not locally diagnosable but require additional instrumentation. To get an idea of the possible cost, it is useful to nail down exactly which additional properties that are not normally known from within the C++ abstract machine would need to be covered by such additional instrumentation. These properties would need to be tracked  at runtime throughout the \emph{entire} program and checked for \emph{every} runtime operation that may be affected.

To diagnose \emph{all} cases of UB in the memory safety categories Initialization, Bounds, Type and Lifetime, instrumentation would have to track all of the following properties:

\begin{itemize}
\item Provenance of all pointers and pointers-to-member;
\item For all storage, whether it has been allocated/freed;
\item For all storage, whether it has been initialised;
\item For all storage, whether it has been created such that it can hold implicit lifetime objects;
\item For all storage, the type of the object associated with it (if any), including whether it is \tcode{const} or \tcode{volatile}
\item For all objects, whether their lifetime has been started/ended;
\item For all objects, whether they are currently being constructed or destroyed;
\item The dynamic type of all \emph{non}-polymorphic objects of class type;
\item For all references, whether they have been initialized;
\item For all addresses that point to  functions, the type of the function.
\end{itemize}

To diagnose UB in the Threading category, instrumentation would have to track, for \emph{all} memory accesses, from which threads that memory is accessed and when these accesses synchronise with each other.

The non-locally diagnosable UB in the Control Flow category concerns operations that are not allowed during construction and destruction of objects with static or thread-local storage duration (\{basic.start.main.exit.during.destruction\} and \{basic.start.term.use.after.destruction\}). To diagnose these, instrumentation would have to insert guards tracking whether such objects are currently being constructed and destroyed.  

Finally, to diagnose UB in the Coroutine category, instrumentation would have to track the suspension state associated with every coroutine handle.

As we know from existing sanitisers, such instrumentation is expensive enough that it is almost never affordable in production. If we were to add instrumentation covering \emph{all} of the above, we would have made C++ free of UB, but performance would worsen by (at least) an order of magnitude, unless special hardware-acceleration for these checks becomes available. Given the overhead of the instrumentation itself, it is not very relevant how expensive the actual \emph{checks} would be (whether a specific pointer is valid at a specific time, etc.), so we refrain from conducting such an analysis here.

\subsection{Well-defined fallback behaviour exists?}

TODO

\subsection{Appropriate mitigation strategy}
\label{mitigation}

TODO

\section{Proposed design}
\label{design}

\subsection{Defining implicit contract assertions}

TODO

\subsection{Applying implicit contract assertions}

TODO

\subsection{Specifying the fallback behaviour}

TODO

\subsection{Providing an escape hatch}

TODO
%Note: this will be about the assume semantic.

\section{Proposed wording}
\label{wording}

TODO

\addcontentsline{toc}{section}{Appendix: UB list}
\section*{Appendix: UB list}

TODO
%Note: this will contain some rendering of the big spreadsheet.

\section*{Document history}
\begin{itemize}
\item \textbf{R0}, 2023-03-08: Initial version.
\item \textbf{R1}, 2024-10-16: Complete rewrite after the WG21 meeting in St. Louis.
\item \textbf{R2}, 2025-05-19: Complete rewrite after the WG21 meeting in Hagenberg.
\end{itemize}

\section*{Acknowledgements}

We wish to thank Herb Sutter, Oliver Rosten, Andrzej Krzemie\' nski, and Roger Orr for their helpful feedback on a previous revision of this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

