\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Implicit contract assertions}
\author{ Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) 
\\ Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net})  
% TODO: Is Gasper still in?  \\ Ga\v sper A\v zman \small(\href{mailto:gasper.azman@gmail.com}{gasper.azman@gmail.com})   \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & P3100R2 \\
Date: &2025-05-19 \\
Project: & Programming Language C++ \\
Audience: & EWG
\end{tabular}

\begin{abstract}
This paper is a proposed additon to the core language UB white paper \cite{P3656R1}. We enumerate all explicitly specified cases of language UB in C++, group them into categories, and classify them along a number of relevant criteria. We discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checks are an appropriate strategy for the majority of cases. We propose to systematically introduce such runtime checks to the C++ Standard via \emph{implicit contract assertions}, building on the Contracts framework adopted for C++26. 
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents*
\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
\label{intro}

Eliminating or at least meaningfully reducing the amount of unbounded \emph{undefined behaviour} (UB) is a critically important objective for improving ``safety''\footnote{In this paper, we never use the term ``safety'' unqualified except in quotes because of the crucial importance to distinguish between different conflicting definitions of that term, such as functional safety and language safety.  See \cite{P3500R1} and \cite{P3578R0} for a discussion of those definitions and recommendations regarding usage of the term ``safety'' in the context of C++.}
and security for the future evolution of the C++ language. WG21 has been continuously working in that direction (for a recent status update, see \cite{Sutter2025} and references therein; for background, see \cite{Sutter2024} and references therein).

At the February 2025 WG21 meeting in Hagenberg, EWG agreed on a framework for a systematic
treatment of core language undefined behaviour in C++: the pursuit of a core language UB white paper in the C++26 timeframe, covering Erroneous Behaviour, Profiles, and Contracts. The current version of that white paper is \cite{P3656R1}, proposing the process and major work items. The proposed process calls for papers to be adopted into the white paper working draft via EWG approval. This is the first such paper.

Further, as major work items, \cite{P3656R1} proposes to enumerate and group all language UB in C++, identify tools to address them, and take a first pass at penciling in which tool to use for each UB case. The goal of this paper is to contribute to all of the above major work items.

In Section~\ref{ub}, we identify and enumerate all language UB explicitly specified in the C++ Standard. We then group all language UB into broad categories such as ``Arithmetic'' and ``Bounds''. We then classify cases of UB along several relevant criteria: whether they are locally diagnosable, how expensive that diagnosis is, and whether there is well-defined fallback behaviour for each case. Finally, we discuss appropriate mitigation strategies for all identified cases of UB, and find that runtime checking is an appropriate strategy for the large majority of cases.

In Section~\ref{design}, we focus on systematically introducing runtime checks for UB detection and mitigation. We propose to implement them via the introduction of \emph{implicit contract assertions} to C++, building on the basic Contracts framework adopted for C++26 via \cite{P2900R14}. We describe how such implicit contract assertions should be specified and how to apply them to all appropriate cases of language UB. For cases of UB where well-defined fallback behaviour exists, we discuss how specifying it allows the program to continue execution past a violated implicit contract assertion without UB. We conclude by proposing an escape hatch to mitigate the runtime cost of such fallback behaviour and avoid performance regressions.

In Section~\ref{wording}, we propose wording for the design in Section~\ref{design} for approval into the white paper.

The first revision (R0) of this paper was published in May 2024. Following informal discussions at the St. Louis meeting, the paper was revised (R1) and presented to SG21 at the Wroc{\l}aw meeting. SG21 voted \emph{unanimously} in favour of our direction for implicit contract assertions:
\vspace{2mm}
\begin{wgpoll}{{SG21 Poll 6, Wroc{\l}aw, 2024-11-22}}
We support the direction of P3100R1 and encourage the authors to come back with a fully specified proposal.
\wgpollresult{19}{6}{0}{0}{0}
Result: Consensus
\end{wgpoll}
\vspace{2mm}

The present revision (R2) is a complete rewrite of the paper that takes into account the above poll, the adoption of \cite{P2900R14} into the C++26 working paper, EWG's decision to publish the core language UB white paper, and the current state of that white paper \cite{P3656R1}.

\section{Enumerating and grouping core language UB}
\label{ub}

\subsection{Methodology and scope}

For this paper, we manually inspected all occurrences of the word ``undefined'' in the current C++ working paper \cite{N5008}. We then constructed a list of all cases of explicitly specified language UB. Our complete list, containing 83 cases of UB, can be found in Appendix~A of this paper. % TODO: add \ref to appendix

We compiled our list independently from another, ongoing effort by a group of WG21 members to enumerate cases of language UB directly in the C++ Standard document  \LaTeX{} source, based on work by Shafik Yaghmour (\cite{P1705R1}, \cite{P3075R0}) and following the process outlined in \cite{P3656R1}. Wherever possible, we use the same stable identifiers for our own list as the \LaTeX-based list does, although we identified a number of defects and omissions in Shafik's list as well as some other differences between the two lists. We are actively contributing to the \LaTeX-based effort to merge the two lists. 

Throughout this paper, we place stable identifiers for cases of UB between \{curly braces\} to visually distinguish them from stable identifiers for clauses in the C++ Standard, which we place between [square brackets].

Note that unlike the \LaTeX-based effort, our list excludes cases of IFNDR, as we focus on runtime checking as a mitigation strategy. While UB is fundamentally a runtime property of a particular program execution, and thus runtime checking is a natural mitigation approach, IFNDR typically represents link-time issues and is therefore out of scope for this paper.

Note further that we exclude \emph{library undefined behaviour}, as the natural mitigation approach for it is library hardening \cite{P3471R4}, which is likewise out of scope for this paper. We therefore only take into account UB is specified in the core language part of the C++ Standard (Clauses 1 --- 15). Further, we found one case of UB that is specified in the core language part of the C++ Standard but actually represents a precondition on C++ Standard library functions;\footnote{\textbf{[basic.start.term]/6}: If there is a use of a standard library object or function not permitted within signal handlers ([support.runtime]) that does not happen before ([intro.multithread]) completion of destruction of objects with static storage duration and execution of \tcode{std::atexit} registered functions ([support.start.term]), the program has undefined behavior.}
that case is also not considered in this paper.

\subsection{Categories}

We found that all identified cases of language UB in the core language can be broadly classified into one of the following basic categories:
\begin{itemize}
\item \textbf{Initialisation} --- 1 case. Evaluating an expression that produces an indeterminate value.
\item \textbf{Bounds} --- 5 cases. Using a pointer in a way that fails to respect the range of the pointed-to object or array. Examples: incrementing a pointer beyond the past-the-end position; performing single-object delete on an operand obtained from an array-new expression;  dereferencing a pointer returned from a request for zero size.
\item \textbf{Type and Lifetime} --- 45 cases. Operations that access storage and/or use pointers or references to storage in an inappropriate way that is not already covered by Initialisation and Bounds. Examples: attempting to access a value of one type through  a pointer of a different, incompatible type; attempting to access the value of an object after its lifetime has ended. 
\item \textbf{Arithmetic} --- 9 cases. Executing an arithmetic operation whose operands fail to meet certain preconditions. Examples: division by zero; conversion of a value to a different arithmetic type that cannot represent that value. 
\item \textbf{Threading} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from different threads where neither access happens-before the other.
\item \textbf{Sequencing} --- 1 case. Performing two concurrent accesses, at least one of which is modifying, to the same memory location from the same thread where neither access is sequenced before the other.
\item \textbf{Assumptions} --- 1 case. Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}.
\item \textbf{Control flow} --- 6 cases. Examples: flowing off the end of a function; re-entering the same declaration recursively when initialising a static variable.
\item \textbf{Replacement functions} --- 3 cases. Executing a user-defined replacement function (\tcode{operator new}/\tcode{delete}) that fails to meet the specified requirements. Examples: returning \tcode{null} from a user-defined placement \tcode{new}; throwing an exception from a user-defined \tcode{delete}.
\item \textbf{Coroutines} --- 2 cases. Misusing coroutine machinery. Destroying a coroutine that is not suspended; invoking a resumption member function for a coroutine that is not suspended.
\item \textbf{Compilation} --- 1 case. Infinite recursion during template instantiation.
\item \textbf{Preprocessor} --- 8 cases. Misusing preprocessor directives. Examples: \tcode{\#define}-ing a predefined macro name; passing an out-of-range integer to the \tcode{\#line} directive.
\end{itemize}

The categories Initialisation, Bounds, Type and Lifetime correspond to the common terms  ``initialisation safety'',  ``bounds safety'', ``type safety'',  and ``lifetime safety'', respectively, and collectively represent undefined behaviour that is commonly referred to with the umbrella term ``memory safety''. 

Note that we grouped ``type safety'' and ``lifetime safety'' into a single combined category Type and Lifetime. This is because it is often impossible to unambiguously categorise a particular case of UB into one or the other bucket as it concerns both. While there are cases of UB that are primarily caused by type aliasing, and others that are primarily caused by out-of-lifetime accesses, they form a spectrum, and many common operations in C++ (e.g., using a reference) rely on \emph{both} type and lifetime constraints to be satisfied. Note further that this combined category Type and Lifetime contains the majority (54\%) of all cases of UB that we identified.

The next two categories, Arithmeric and Threading, correspond to the common terms ``arithmetic safety'' and ``thread safety'', respectively.

The following category, Sequencing, contains just one case of UB: unsequenced operations such as \mbox{\tcode{i++ + ++i}}. It might seem surprising at first that we grouped threading and sequencing into two separate categories as their specification has a very similar same shape (except that one is inter-thread and the other is intra-thread). However, as we will see in Section~\ref{mitigation}, these two categories actually require very different approaches to mitigation.

The next category, Assumptions, also contains just one case of UB: Reaching an \tcode{[[assume]]} declaration whose operand would not evaluate to \tcode{true}. As we will see in Section~\ref{mitigation}, this case of UB is of a different nature than the others and warrants its own category.

The final five categories (Control flow, Replacement functions, Coroutines, Compilation failures, and Preprocessor) are much less frequently discussed in the current discourse around UB. Nevertheless, they represent UB that needs to be mitigated somehow.

\subsection{Security-related?}

\cite{P3656R1} asks the question which cases of UB are security-related. The paper suggests to have security experts tag which cases of UB have security impact always, never, or sometimes. As we are not security experts, we do not attempt to do this here. However, we will note that cases of UB commonly associated with security vulnerabilities (see for example the CWE list at \url{https://cwe.mitre.org/}) fall into the categories Initialisation, Bounds, Type and Lifetime. 

Other cases of UB, such as those in categories Arithmetic and Threading, are a common source of program defects, and those program defects do sizeable damage to existing software, so there is a lot of value in mitigating them, but to our knowledge they are not commonly exploited by malicious attackers.

\subsection{Locally diagnosable?}
\label{locally}

The second question that \cite{P3656R1} asks is which cases of UB are ``efficiently locally diagnosable''. Here, we break this down into two separate questions: which cases of UB are known to be locally diagnosable (this subsection), and what the cost of diagnosis is (next subsection).

Most cases in the security-critical Initialisation, Bounds, Type and Lifetime categories are \emph{not} locally diagnosable. 

From the Bounds category, 
\{expr.add.out.of.bounds\} 
and \{expr.add.sub.diff.pointers\} 
are partially locally diagnosable (only if the array bound is statically known).

From the Type and Lifetime category,
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}
are partially locally diagnosable (for the null pointer case).
\{expr.mptr.oper.member.func.null\} is locally diagnosable because this case requires \emph{only} a null pointer check.
\{basic.align.object.alignment\} is locally diagnosable by checking the alignment of storage when creating an object at runtime.
\{expr.assign.overlap\} is locally diagnosable by checking the overlap of the two address ranges (the ranges are known because the address and \tcode{sizeof} are known at runtime for both the source and the destination object). \{class.abstract.pure.virtual\} is locally diagnosable by adding a runtime check to  the pure virtual function stub that the base class vtable points to.

All other cases of UB in the Initialisation, Bounds, Type and Lifetime categories require additional instrumentation to be diagnosable, of the kind that is implemented in sanitisers such as ASan and UBSan (see Section~\ref{cost} for details).

All cases of UB in the Arithmetic category are locally diagnosable as they are all cases of an arithmetic operation producing a value that is somehow inappropriate (mathematically invalid, not representable in the target type, etc.) and that value can be inspected at runtime.

UB in the Threading category (\{intro.races.data\}) is not locally diagnosable, but UB in the Sequencing category (\{intro.execution.unsequenced.modification\}) is. 

UB in the Assumption category is in principle locally diagnosable by evaluating the operand of the assumption and checking whether the resulting value, contextually converted to \tcode{bool}, equals \tcode{true}. However, if that evaluation has any side effects, the check could alter the observable state of the program. This means that even if the given assumption holds and there is no UB, the check itself might render the program invalid by altering its state. Therefore, this UB is only meaningfully diagnosable at all in any automated fashion if the operand has no side effects when evaluated. However, proving that the operand has no side effects is in general not possible either (Halting problem). 

Some cases of UB in the Control Flow category are locally diagnosable. \{stmt.return.flow.off\} and \{stmt.return.coroutine.flow.off\} can be diagnosed by inserting a check at the end of every function body that does not end with a \tcode{return} or \tcode{co_return} statement. \{dcl.attr.noreturn.eventually.returns\} can be diagnosed by inserting a check into every function declared \tcode{[[noreturn]]}

Some cases of UB in the Replacement Function category are partially or fully locally diagnosable. In particular, some of the constraints specified in \{basic.stc.alloc.dealloc.constraint\} and \{expr.new.non.allocating.null\} are locally diagnosable, while others are not. In particular, it is possible to check locally that a deallocation function does not exit via an exception, and that an allocation function does not return null. However, is not possible to check the other constraints (locally or at all).

All cases of UB in the Coroutine category are not locally diagnosable.

UB in the Compilation and Preprocessor categories is unique in that it does not actually represent run-time UB and therefore, run-time diagnosis does not make any sense. In particular, UB in the Compilation category (\{temp.inst.inf.recursion\}) is diagnosable at compile time, while UB in the Preprocessor category should be IFNDR instead (see also Section~\ref{mitigation}).

\subsection{Cost of diagnosis}
\label{cost}

To estimate the cost of diagnosis, it is useful to consider locally diagnosable and not locally diagnosable cases of UB separately. Note that in this paper, we study the theoretical, relative cost based on the current specification of the C++ language, however we do not measure the actual cost of diagnosis in real implementations and we do not present benchmarks; this is left for future studies.

\subsubsection{Locally diagnosable}

For locally diagnosable cases, there is always some kind of runtime check --- an \emph{assertion} --- that could be inserted by the implementation and then evaluated at runtime. The total cost of diagnosis is therefore equal to the cost of evaluating that check multiplied by the number of times the check needs to be evaluated.

The cheapest kind of check, and the only one that has no overhead for the happy case, is the ``fail if you get here'' check --- effectively a \tcode{pre}/\tcode{post}/\tcode{contract_assert(false)}. This kind of check is sufficient to diagnose \{class.abstract.pure.virtual\}, \{stmt.return.flow.off\}, \{stmt.return.coroutine.flow.off\}, and \{dcl.attr.noreturn.eventually.returns\}.

A slightly more expensive, but still cheap and optimiser-friendly kind of check is a null check, required to diagnose the null pointer cases  
(
\{expr.static.cast.downcast.wrong.derived.type\},
\{expr.unary.dereference\},
\{conv.ptr.virtual.base\}, and
\{expr.dynamic.cast.lifetime\}, 
\{expr.mptr.oper.member.func.null\}, and
\{expr.new.non.allocating.null\}
) as well as division by zero (\{expr.mul.div.by.zero\}).

Similarly cheap and optimiser-friendly are integer comparisons. These are  required for bounds checks with statically known array bounds
(
\{expr.add.out.of.bounds\},
\{expr.add.sub.diff.pointers\}
), as well as for \{expr.shift.neg.and.width\} and for \{intro.execution.unsequenced.modification\}.

Beyond this, there are a number of UB cases that can still be checked by a straightforward arithmetic expression, but with increasingly expensive expressions: \{expr.assign.overlap\} requires computing whether two integer ranges overlap, and  \{basic.align.object.alignment\} requires computing an integer modulo. 

At the expensive end of this spectrum lie runtime checks for which there is no corresponding C++ expression; instead the compiler would have to generate elaborate ``magic'' checks based on knowledge not available in the C++ abstract machine. In particular, this is the case for all arithmetic UB except \{expr.add.out.of.bounds\} and
\{expr.add.sub.diff.pointers\}. The compiler would have to validate the bit patterns of values of arithmetic types according to knowledge it has about how values of such types are represented on the given platform. Such checks can be done locally, but they can make operations involving built-in types and in particular floating-point types very slow.

In addition to the cost of the check itself, we need to consider the frequency with which these checks would need to be done. Checks that would need to happen once when a function is called or when a function returns are likely to be acceptable in most scenarios. Extensive checks for arithmetic UB will probably be acceptable in fewer scenarios because they would significantly slow down arithmetic operations, which are performance-sensitive in many contexts. On the extreme end, if we wanted to diagnose \{intro.execution.unsequenced.modification\} via a runtime check, the check in itself would not be very expensive but the compiler would have to put this check on every possible pair of unsequenced operations everywhere, which can lead to a combinatorial explosion for complex expressions.
% TODO: Is this last statement actually true? I'm not sure.
\subsubsection{Not locally diagnosable}

As we saw in Section~\ref{locally}, most cases of UB are not locally diagnosable but require additional instrumentation. To get an idea of the possible cost, it is useful to nail down exactly which additional properties that are not normally known from within the C++ abstract machine would need to be covered by such additional instrumentation. These properties would need to be tracked  at runtime throughout the \emph{entire} program and checked for \emph{every} runtime operation that may be affected.

To diagnose \emph{all} cases of UB in the memory safety categories Initialization, Bounds, Type and Lifetime, instrumentation would have to track all of the following properties:

\begin{itemize}
\item Provenance of all pointers and pointers-to-member;
\item For all storage, whether it has been allocated/freed;
\item For all storage, whether it has been initialised;
\item For all storage, whether it has been created such that it can hold implicit lifetime objects;
\item For all storage, the type of the object associated with it (if any), including whether it is \tcode{const} or \tcode{volatile};
\item For all objects, whether their lifetime has been started/ended;
\item For all objects, whether they are currently being constructed or destroyed;
\item The dynamic type of all \emph{non}-polymorphic objects of class type;
\item For all references, whether they have been initialized;
\item For all addresses that point to  functions, the type of the function.
\end{itemize}

To diagnose UB in the Threading category, instrumentation would have to track, for \emph{all} memory accesses, from which threads that memory is accessed and when these accesses synchronise with each other.

The non-locally diagnosable UB in the Control Flow category concerns operations that are not allowed during construction and destruction of objects with static or thread-local storage duration (\{basic.start.main.exit.during.destruction\} and \{basic.start.term.use.after.destruction\}). To diagnose these, instrumentation would have to insert guards tracking whether such objects are currently being constructed and destroyed.  

Finally, to diagnose UB in the Coroutine category, instrumentation would have to track the suspension state associated with every coroutine handle.

As we know from existing sanitisers, such instrumentation is expensive enough that it is almost never affordable in production. If we were to add instrumentation covering \emph{all} of the above, we would have removed vast swathes of UB from the language, but performance would worsen by (at least) an order of magnitude, unless special hardware-acceleration for these checks becomes available.
% TD: should we also talk about the fact that instrumentation can add new security vulnerabilities?

Given the overhead of the instrumentation itself, it is not particularly important how expensive the actual \emph{checks} would be (whether a specific pointer is valid at a specific time, etc.), because the performance penalty would be dominated by the instrumentation overhead. 

\subsection{Well-defined fallback behaviour}
\label{fallback}

If we want to turn UB into well-defined behaviour, a particularly relevant question is whether there actually exists any well-defined behaviour that the affected operation could exhibit instead of UB in the presence of a bug. Here, we call such well-defined behaviour \emph{fallback behaviour}.

We could also use the term \emph{erroneous behaviour} (EB), which is conceptually the same thing. However, since the approval of \cite{P2795R5} for C++26, EB has very specific semantics. Here, we are considering the wider concept of introducing new well-defined behaviour for error cases, rather than the exact semantics that EB has in C++26, therefore we use a different term for now.

For fallback behaviour to happen, the necessary instructions need to be laid down by the compiler. However, all cases of language UB (except those in categories Compilation and Preprocessor) are fundamentally \emph{not} diagnosable at compile time (see Section~\ref{locally}), i.e., whether or not the UB will occur depends on runtime parameters. Fallback behaviour can therefore \emph{not} depend on knowing that an error occurred. For non-locally diagnosable UB, fallback behaviour can also not depend on any extra instrumentation being present.

In this section, we systematically identify all cases of language UB for which such fallback behaviour exists. As we will see, even if such fallback behaviour exists, it is not necessarily cheap.

UB in the Initialization category (\{basic.indet.value\}) has a possible fallback behaviour for built-in types: return an erroneous value instead. For variables with automatic storage duration, this fallback behaviour is already part of C++26 as EB via \cite{P2795R5}, because for this case, the fallback behaviour is particularly cheap. The same fallback behaviour could also be employed for dynamically allocated variables, but at greater cost (see \cite{P2723R1} Section 6 for discussion). 

For user-defined types, such fallback behaviour does not exist in general. Even if we could zero out all the memory for user-defined types, that does not always produce a valid value for that type which can be accessed without UB (consider a user-defined type that relies on a member of pointer type never being null). Therefore, (\{basic.indet.value\} does not have fallback behaviour for the general case.

Practically \emph{none} of the UB in the categories Bounds, Type and Lifetime has fallback behaviour. The only exception is \{conv.lval.valid.representation\}: if the bits in the value representation of an object of built-in type are not valid for that type, the compiler could instead coerce the value into an erroneous value. For example, in the code example given in the C++ Standard,

\begin{codeblock}
bool f() {
  bool b = true;
  char c = 42;
  memcpy(&b, &c, 1);
  return b;         // undefined behavior if \tcode{42} is not a valid value representation for \tcode{bool}
}
\end{codeblock}

the UB could be replaced by well-defined behaviour by appropriately bit-masking every accessed \tcode{bool} value. Similar mitigations could be put in place for other built-in types since the space of allowed bit representations for values of those types, for the target platform in question, are known to the compiler. Obviously such mitigations would have a very significant performance overhead.

All UB in the Arithmetic category has the same possible fallback behaviour: if an arithmetic operation would produce an inappropriate value, it can be coerced into an erroneous value instead, at the cost of incurring significant overhead on common arithmetic operations.

It is possible to define fallback behaviour for UB in the Threading category (\{intro.races.data\}): we can make all primitive memory accesses implicitly atomic, as in the Java model. The overhead incurred by such a model will heavily depend on the memory model of the underlying hardware; on weakly-ordered platforms such as ARM it will be larger than on strongly-ordered platforms such as x86. Note that while such fallback behaviour is well-defined, it still leads to a pretty bad user experience as user-defined types with multiple members can end up with torn values.

The fallback behaviour for UB in the Sequencing category (\{intro.execution.unsequenced.modification\}) is much more straightforward: we can simply define that the unsequenced operations happen in some unspecified order. This fallback behaviour can still have performance overhead in the form of losing  optimisation opportunities, but it seems likely that such overhead will be manageable. This case may be a good candidate for a study actually implementing the mitigation and measuring the overhead.

The fallback behaviour for UB in the Assumption category (\{dcl.attr.assume.false\}) is trivial: just ignore the assumption, instead of optimising based on it. The performance overhead is limited to losing any optimisation opportunities from placing the assumption there. Of course, this mitigation makes the assumption itself completely useless. We will discuss this case in more detail in Section~\ref{assume}.

Finally, we can define partial fallback behaviour for two cases of UB in the Control Flow category  (\{stmt.return.flow.off\} and \{stmt.return.coroutine.flow.off\}): whenever the function or coroutine would return a value of built-in type, we can define that flowing off the end returns an erroneous value. This case is analogous to \{basic.indet.value\}; again, no fallback behaviour exists for user-defined return types in the general case.

For all other cases of UB (80\% of all cases) we cannot come up with any meaningful fallback behaviour.

\subsection{Mitigation strategies}
\label{mitigation}

In this section, we attempt, at a very high level, to systematically identify candidate mitigation strategies for all cases of language UB.

Arguably, the best mitigation strategy is to make the offending construct ill-formed. However, if we want to avoid breaking existing correct C++ code, we can only do this for cases where we can unambiguously identify at \emph{compile time} that UB will occur. This is the case only for one case of UB: 
\{temp.inst.inf.recursion\}. There is no good reason for this kind of error to be specified as UB; it should be specified as ill-formed instead.

Similarly, UB in the Preprocessor category should not be specified as UB either. We defer to \cite{P2843R2}, which proposes to specify all these cases as IFNDR instead, placing them outside of the scope of this paper.

There is one more case of UB which should not actually be considered UB: \{class.dtor.not.class.type\}. While the wording for this case says that ``if the object is not of the destructor's class type and not of a class derived from the destructor's class type (including when the destructor is invoked via a null pointer value), the program has undefined behaviour'', this is not a new case of UB but already falls out from the specification of other cases of UB elsewhere. This section should therefore be a non-normative note referring to those sections.

This leaves us with 73 cases of UB for which we need to identify candidate mitigation strategies. All of those cases represent \emph{run-time} UB that cannot be diagnosed at compile time. Therefore, one possible mitigation strategy for \emph{all} of those cases of UB is to insert \emph{run-time} checks.

Fundamentally, inserting run-time checks is possible for all those 73 cases of UB. However, as we saw in Section~\ref{locally}, the majority of those cases require expensive sanitiser-like instrumentation to perform the checks, and even for locally diagnosable cases of UB where additional instrumentation is not required, the checks themselves have a significant runtime overhead in almost all cases. Therefore, the checks need to be \emph{optional}: we need a mechanism to enable and disable each kind of check, and we cannot require an implementation to support all checks.

For example, a compiler may choose to support enabling runtime checks for arithmetic UB (they already do today for some cases, for example GCC offers the \tcode{-ftrapv} flag which enables checks for signed integer overflow) while not supporting any checks that require expensive instrumentation. On the other hand, a different compiler that comes with a suite of a sanitisers may choose to support some subset of those more expensive checks (and again, they already do today).

It is therefore useful to define such optional run-time checks for all those 73 cases of UB. These checks cost \emph{nothing} unless they are turned on, no implementation is actually \emph{required} to implement them, but specifying them in the Standard allows us to assign standard names and categories to them, ... %JMB: please list more benefits of doing this!!

The natural way to introduce such optional run-time checks to C++ is to leverage the Contracts framework. All the necessary machinery and terminology for optional run-time checks --- called \emph{contract assertions} --- is already present in C++26, thanks to the foundation laid by \cite{P2900R14}. The only missing part is to introduce compiler-generated checks, i.e., \emph{implicit} contract assertions, in addition to the user-authored, i.e., \emph{explicit} contract assertions added by \cite{P2900R14}, and to hook those contract assertions into the same contract-checking and violation-handling machinery. We propose to do exactly this in Sections \ref{defineicas} and \ref{applyicas}.

In addition to introducing implicit contract assertions, which let us \emph{diagnose} the UB, we can actually \emph{remove} the UB for those 17 cases of run-time UB where meaningful, well-defined fallback behaviour exists (see Section~\ref{fallback}). This can be accomplished by defining that the behaviour of the operation in question is that fallback behaviour; we propose to do this in Section~\ref{specifyfallback}.

However, practically all of this fallback behaviour comes with non-negligible --- and in some cases, even very large --- performance overhead. Therefore, to avoid unacceptable performance regressions in existing, correct C++ code, we \emph{must} offer an escape hatch that reverts to today's ``unsafe'' semantics.

The existing case of EB for uninitialised values offers a specific escape hatch: the \tcode{[[indeterminate]]} attribute. However, in many cases such a specific, syntactic escape hatch is simply not viable. Consider e.g. arbitrary arithmetic expressions where some integer operations may overflow --- where would you put a syntactic escape hatch? Therefore, we need a generic escape hatch that does not rely on syntax. We propose such an escape hatch in Section~\ref{assume}.

For the 56 cases of run-time UB where meaningful, well-defined fallback behaviour does not exist (and therefore, continuation after an error has occurred is not possible), there are in principle only two known ways to give all those cases defined behaviour at runtime:
\begin{itemize}
\item to \emph{diagnose} them (and pay all the overhead for the associated run-time checks) and then terminate the program, or
\item to make the entire construct that could potentially exhibit the given case of UB ill-formed, and provide its functionality via a different, ``safer'' language feature.
\end{itemize}

The fundamental dilemma is that for many cases, neither alternative is acceptable. The instrumentation required to diagnose Bounds, Type, and Lifetime UB in the general case already exists, but its overhead is prohibitively large for most production scenarios. On the other hand, replacement by ``safer'' alternative features, such as replacing pointers and references with borrow checking as proposed in \cite{P3390R0}, is viable for newly written code but fundamentally not compatible with legacy code as it would make vast swathes of existing, \emph{correct} C++ ill-formed.

Such subsetting of the language is exactly where we see the role of Profiles. Enabling a particular profile would make the associated set of ``unsafe'' legacy features ill-formed. By leveraging profiles, the user can explicitly distinguish between newly written, ``safe'' parts of the code and legacy, ``unsafe'' parts, similarly to how this is done in languages like Rust, but with much greater granularity.

On the other hand, we do not believe that Profiles should intersect with runtime behaviour, as proposed by  \cite{P3081R1}. Enabling or disabling a profile should never change the runtime semantics of a C++ program. % JMB: please explain why not!! 
At most, a profile could reject the program if a certain run-time check required by the chosen ``safety'' level is not available (making Profiles a useful auditing tool), but a profile should never dictate whether a run-time check is enabled or disabled, or what should happen if that check fails. The reason is that, as we will see in Section~\ref{design} of this paper, all the required machinery for configuring run-time checks is already provided by the Contracts framework in a more consistent manner.

\section{Proposed design}
\label{design}

\subsection{Defining implicit contract assertions}
\label{defineicas}

TODO

\subsection{Applying implicit contract assertions}
\label{applyicas}

TODO

\subsection{Specifying the fallback behaviour}
\label{specifyfallback}

TODO

\subsection{Providing an escape hatch}
\label{assume}

TODO
%Note: this will be about the assume semantic.


\section{Proposed wording}
\label{wording}

TODO

\addcontentsline{toc}{section}{Appendix: UB list}
\section*{Appendix: UB list}

TODO
%Note: this will contain some rendering of the big spreadsheet.

\section*{Document history}
\begin{itemize}
\item \textbf{R0}, 2023-03-08: Initial version.
\item \textbf{R1}, 2024-10-16: Complete rewrite after the WG21 meeting in St. Louis.
\item \textbf{R2}, 2025-05-19: Complete rewrite after the WG21 meeting in Hagenberg.
\end{itemize}

\section*{Acknowledgements}

We wish to thank Herb Sutter, Oliver Rosten, Andrzej Krzemie\' nski, and Roger Orr for their helpful feedback on a previous revision of this paper.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}

