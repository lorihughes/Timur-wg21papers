\input{wg21common}

% Footnotes at bottom of page:
 \usepackage[bottom]{footmisc} 

% Table going across a page: 
 \usepackage{longtable}

 % Start sections at 0
% \setcounter{section}{-1}

% color boxes
\usepackage{tikz,lipsum,lmodern}
\usepackage[most]{tcolorbox}

% To make Josh's \iref command work here
\renewcommand{\iref}[1]{([#1])}

% Indent code that needs to be outside of codeblock because we need green underline
\newcommand{\codetab}[0]{\phantom{\tcode{xx}}}
\newcommand{\codelongtab}[0]{\phantom{\tcode{xxxxxxxx}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TABLE OF CONTENTS SETTINGS

\usepackage{titlesec}
\usepackage{tocloft}

% Custom ToC layout because the default sucks
\cftsetindents{section}{0in}{0.24in}
\cftsetindents{subsection}{0.24in}{0.34in}
\cftsetindents{subsubsection}{0.58in}{0.44in}

% Needed later to reduce the ToC depth mid document
\newcommand{\changelocaltocdepth}[1]{%
  \addtocontents{toc}{\protect\setcounter{tocdepth}{#1}}%
  \setcounter{tocdepth}{#1}%
}

\setcounter{tocdepth}{3}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%POLLS

\definecolor{pollFrame}{rgb}{0,.718,0}
\definecolor{pollBG}{rgb}{.5,1,.5}

\newtcolorbox{wgpoll}[1]{colframe=pollFrame,colback=pollBG!20!white,title={#1}}

\newcommand{\wgpollresult}[5]{%

  \vspace{2mm}
  \begin{tabular}{c | c | c | c | c} %
  SF  & F  & N  & A  & SA \\ %
  \hline %
  #1 & #2 & #3 & #4 & #5 \\ %

  \end{tabular}
  \vspace{2mm}  \\ %
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\title{Making erroneous behaviour consistent with Contracts}
\author{
Timur Doumler \small(\href{mailto:papers@timur.audio}{papers@timur.audio}) \\
Joshua Berne \small(\href{mailto:jberne4@bloomberg.net}{jberne4@bloomberg.net}) \\
}
\date{}
\maketitle

\begin{tabular}{ll}
Document \#: & D3329R0 \\
Date: &2025-01-13 \\
Project: & Programming Language C++ \\
Audience: & EWG, LEWG
\end{tabular}

\begin{abstract}
This paper proposes the first step towards \cite{P3100R1} --- a unified framework for describing and handling incorrect C++ programs. In this framework, undefined behavior, erroneous behavior, and contract violations are all different aspects of a coherent whole. While most of the changes proposed in \cite{P3100R1} can wait until C++29, this paper contains the part that needs to be adopted for C++26 to avoid setting in stone inconsistencies between the concepts of ``erroneous behaviour'' on the one hand and ``contract violation'' on the other hand that would permanently preclude future evolution towards \cite{P3100R1}.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\tableofcontents*
%\pagebreak

%\section*{Revision history}

%Revision 0 (2024-04-16)
%\begin{itemize}
%\item Original version
%\end{itemize}

%\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Motivation and context}
\label{motivation}

C++ is at an inflection point. To effectively address the safety and security challenges currently facing the C++ ecosystem, a \emph{holistic} strategy is needed.

A key part of this strategy is to introduce to the C++ Standard a unified framework for describing programs that are \emph{incorrect}, i.e. whose source code has a bug, and mitigating such bugs during program execution, without leaving the behaviour undefined. This approach is complementary to introducing \emph{static} language guarantees that make unsafe constructs ill-formed, and targets bugs that cannot be prevented statically.

Such a unified framework is being proposed in \cite{P3100R1}. That proposal is large and the proposed specification is not yet complete; it is thus not in scope for C++26. However, there is a small subset of \cite{P3100R1} that must be applied \emph{before} we ship C++26, otherwise we would be setting in stone inconsistencies that would permanently preclude future evolution towards \cite{P3100R1}. This paper proposes to apply just this part to the C++26 Working Draft.

The issue is that we have \emph{two} separate specification tools for describing incorrect programs heading towards C++26: \emph{erroneous behaviour} (\cite{P2795R5}; already merged into the C++26 WD) and \emph{contract violation} (\cite{P2900R13}). Both convey the same concept: a program that encounters erroneous behaviour --- or a contract violation --- is known to be defective, yet its behaviour at that point is well-defined. Both offer the implementation essentially the same options for mitigation --- [intro.abstract] specifies:
\begin{adjustwidth}{0.5cm}{0.5cm}
If the execution contains an operation specified as having erroneous behaviour, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution at an unspecified time after that operation.
\end{adjustwidth}
Note that the four possible combinations of issuing a diagnostic or not, and terminating execution or not, map exactly to the four evaluation semantics in \cite{P2900R13}: \emph{ignore}, \emph{observe}, \emph{enforce}, and \emph{quick-enforce}. An expression \tcode{E} that evaluates to an erroneous value is thus essentially equivalent to the following function:

\begin{codeblock}
auto eval_E() 
post (r: !is_erroneous(r) { 
  return E;
}
\end{codeblock}

Even though conceptually, the two notions are the same, unfortunately the terminology between them is incompatible, and worse, there are a handful of subtle differences in specification. 

The \textbf{first} inconsistency is that, while printing a diagnostic message is a default handling strategy for both contract violations and erroneous behaviour --- \cite{P2900R13} calls this the \emph{default contract-violation handler}\footnote{Strictly speaking, the effects of the default contract-violation handler are implementation-defined, so an implementation could choose to do anything, but the recommended practice in \cite{P2900R13} is that the default contract-violation handler prints a diagnostic message, and we expect this recommended practice to be followed on all major compilers. Note that this behaviour is also backwards-compatible with the default behaviour of the C \tcode{assert} macro.}  --- Contracts allow the user to override this behaviour and install their own user-defined contract-violation handler, while erroneous behaviour does not. Yet doing so is existing practice: UBSan, an implementation that detects erroneous behaviour, does in fact offer an API\footnote{All Clang sanitisers offer the API \tcode{__sanitizer_set_death_callback} for this purpose; ASan additionally offers a slightly more sophisticated API \tcode{__asan_set_error_report_callback}.} that allows the user to install a custom handler. As discussed in \cite{P3100R1}, there are many benefits in standardising an API for such callbacks via the replaceable contract-violation handler, and allowing any program defect detected during program execution, including erroneous behaviour, to trigger that same handler.
 
The \textbf{second} inconsistency is that, when a \cite{P2900R13} postcondition assertion is evaluated with a terminating semantic (\emph{enforce} or \emph{quick-enforce}) and a contract violation has been detected, \cite{P2900R13} specifies exactly which modes of termination are conforming (namely, the three erroneous termination modes available in C++: \tcode{std::terminate}, \tcode{std::abort}, and immediate termination, such as via a trap instruction --- all of which have important use cases), while erroneous behaviour does not.

The \textbf{third} inconsistency is that with \cite{P2900R13}, if the program is terminated due to a contract violation, that happens immediately after the violation has been handled; on the other hand, if erroneous behaviour is encountered, termination happens ``at an unspecified time after that operation'', introducing some sort of ``Damocles semantic'' that makes it much harder to reason about the behaviour of the program.

Finally, the \textbf{fourth} inconsistency concerns contract violations encountered during constant evaluation. If the evaluation of an expression results in erroneous behaviour, then according to the current specification in [expr.const], this disqualifies the expression from being a core constant expression, which in turn allows the user to SFINAE on whether an expression results in erroneous behaviour. This is incompatible with how contract violations are treated in \cite{P2900R13}: if an \emph{enforced} contract assertion fails during constant evaluation, the program is straight up ill-formed. A discussion of why such compile-time branching on the presence of a bug should never be allowed can be found in \cite{P2900R13} Section 3.1, which enshrines this design principle as the so-called \emph{Contracts Prime Directive}.

In order to remove all these inconsistencies and pave the way towards the unified framework proposed in \cite{P3100R1}, we need to change the terminology and specification of erroneous behaviour to align with Contracts, and we need to do so before shipping erroneous behaviour in C++26.

% TD: I'm not sure we need the following paragraph, or whether it is even a good explanation. I initially added it to address John L's objection who was saying that EB and Contracts are totally different things. But now it feels like it's detracting so I commented it out again. Thoughts?
%It has been suggested that erroneous behaviour is conceptually different from a contract violation. This is not true; rather, erroneous behaviour is a specific flavour of contract violation: on the one hand, we know that there is a bug in the code (therefore, it is a contract violation), on the other hand we also know that ignoring the bug and continuing program execution cannot lead to undefined behaviour (because an erroneous value is \emph{not} an indeterminate value). This flavour is perfectly compatible with the general notion of contract assertions --- since contract assertions are, first and foremost, \emph{correctness checks}, all contract assertions guard against bugs, but not all contract assertions guard against undefined behaviour. This is true for explicit (user-authored) contract assertions as well as for implicit ones.

\section{Proposed design}

\subsection{Implicit contract assertions}

The first  and most important step towards the unified design proposed in \cite{P3100R1} is to extend the concept of \emph{contract assertion} in \cite{P2900R13} by distinguishing between \emph{explicit} contract assertions and \emph{implicit} contract assertions. Explicit contract assertions are those that \cite{P2900R13} proposes. They are added to the program explicitly using function contract specifiers --- \tcode{pre(...)} and \tcode{post(...)} --- and assertion statements --- \mbox{\tcode{contract_assert(...)}}. By contrast, implicit contract assertions are not directly visible in program code, but injected into the program by the implementation. Otherwise, explicit and implicit contract assertions behave the same. Importantly, they can be evaluated with the same four evaluation semantics --- \emph{ignore}, \emph{observe}, \emph{enforce}, and \emph{quick-enforce} --- and they call the same global contract-violation handler.

The second step is to recognise that the occurrence of erroneous behaviour --- such as when a builtin operation results in an erroneous value --- is equivalent to the violation of an implicit contract assertion that the operation does \emph{not} result in an erroneous value. We can then remove the notion of erroneous behaviour from C++ entirely and instead say that the evaluation of any builtin operation includes an implicit postcondition assertion that it does not produce an erroneous value. Following \cite{P2900R13}, that implicit postcondition assertion can then be evaluated with any of the four evaluation semantics, a violation can trigger the contract-violation handler, etc. This modification instantly removes all four inconsistencies described in Section~\ref{motivation}.

Note that the same strategy can be applied in the same way to all other cases where the implementation determines at runtime that the program code has a bug. This includes all occurrences of undefined behaviour which \cite{P2795R5}, Section ``The Broader Picture'' lists as a ``candidate for conversion to erroneous behaviour'': signed integer overflow, unrepresentable arithmetic conversions, bad bitshifts, and so on. We make all these operations safe by specifying the appropriate implicit precondition or postcondition assertions and a well-defined fallback behaviour; see \cite{P3100R1}. It also includes implicit contract violations inserted by Profiles; see \cite{P3081R1}.

\subsection{Extending the contract-violation handling API}

TODO

% - new kind
% - new detection mode
% - again mention profiles

\subsection{Replacing the ``Damocles semantic'' by ``sticky'' erroneous values}

TODO

% TD: Josh, can you write up this subsection? I could try but I think you have a much deeper understanding of how this is supposed to work or why it is necessary

\subsection{Interaction with \tcode{noexcept}}

TODO

\subsection{Constant evaluation}

TODO

% - always enforced
% - No SFINAE on erroneous-ness

\section{Proposed wording}

The changes proposed in this section are relative to the C++ Working Draft \cite{N5001} with the changes proposed in \cite{P2900R13} already applied.

Replace ``contract assertion'' with ``explicit contract assertion'' in all places in the wording that do not apply to implicit contract assertions (not reproduced here because of the large amount of such places).

Remove [defns.erroneous]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\removed{\textbf{erroneous behavior}}

\removed{well-defined behavior that the implementation is recommended to diagnose}

\removed{[ \emph{Note to entry:} Erroneous behavior is always the consequence of incorrect program code. Implementations are allowed, but not required, to diagnose it ([intro.compliance.general]). Evaluation of a constant expression ([expr.const]) never exhibits behavior specified as erroneous in Clause 4 through Clause 15.--- \emph{end note} ]}
\end{adjustwidth}

Modify [intro.compliance.general], footnote 3:

\begin{adjustwidth}{0.5cm}{0.5cm}
“Correct execution” can include undefined behavior and \removed{erroneous behavior}\added{contract violations ([basic.contract])}, depending on the data being processed; see Clause 3 and [intro.execution].
\end{adjustwidth}

Modify [intro.abstract]:

\begin{adjustwidth}{0.5cm}{0.5cm}
A conforming implementation executing a well-formed program shall produce the same observable behavior as one of the possible executions of the corresponding instance of the abstract machine with the same program and the same input. However, if any such execution contains an undefined operation, this document places no requirement on the implementation executing that program with that input (not even with regard to operations preceding the first undefined operation). \removed{If the execution contains an operation specified as having erroneous behavior, the implementation is permitted to issue a diagnostic and is permitted to terminate the execution at an unspecified time after that operation.}

\removed{\emph{Recommended practice:} An implementation should issue a diagnostic when such an operation is executed.}

\removed{[ \emph{Note:} An implementation can issue a diagnostic if it can determine that erroneous behavior is reachable under an implementation-specific set of assumptions about the program behavior, which can result in false positives. --- \emph{end note} ]}
\end{adjustwidth}

Modify [basic.contract.general] as follows:
\begin{adjustwidth}{0.5cm}{0.5cm}
Contract assertions \removed{allow the programmer to }specify properties of the state of the program that are expected to hold at certain points during execution.

\added{\emph{Explicit} c}\removed{C}ontract assertions are introduced by \emph{precondition-specifier}s, \emph{postcondition-specifier}s ([dcl.contract.func]), and \emph{assertion-statement}s ([stmt.contract.assert]). \added{\emph{Implicit} contract assertions are inserted into the program by the implementation.}

Each contract assertion has a \emph{predicate}, which is an expression of type \tcode{bool}. \removed{[ \emph{Note:} The value of the predicate is used to identify program states that are expected. --- \emph{end notea} ]} \added{If it is determined during program execution that the predicate has a value other than \tcode{true}, a \emph{contract violation} occurs. A contract violation is always the consequence of incorrect program code.}
\end{adjustwidth}

Modify [basic.contract.eval]:

\begin{adjustwidth}{0.5cm}{0.5cm}
An evaluation of a contract assertion uses one of the following four \emph{evaluation semantics}: \emph{ignore}, \emph{observe}, \emph{enforce}, or \emph{quick-enforce}. Observe, enforce, and quick-enforce are checking semantics; enforce and quick-enforce are terminating semantics.

Which evaluation semantic is used for any given evaluation of a contract assertion is implementation-defined. \added{During constant evaluation, an implicit contract assertion is always evaluated with the enforce semantic.} [ \emph{Note:} The evaluation semantics can differ for different evaluations of the same contract assertion, including evaluations during constant evaluation. --- \emph{end note} ]
% TD: Josh: This note looks a bit weird now with the addition before it. Any idea how to improve it?

\emph{Recommended practice:} An implementation should provide the option to translate a program such that all evaluations of contract assertions use the ignore semantic as well as the option to translate a program such that all evaluations of contract assertions use the enforce semantic. By default, evaluations of contract assertions should use the enforce semantic.
% TD: Josh: That recommended practice also no longer works because we now recommend that the implementation should provide something that we say shall never happen in the previous paragraph. But carving out an exception for implicit contract assertions during constant evaluation right here also seems really ugly. Do you have any better idea?
\end{adjustwidth}

Modify [basic.indet] as follows:

% TD: It seems like the latest draft N5001 has different wording than the below; this diff needs to be rebased on that.

\begin{adjustwidth}{0.5cm}{0.5cm}
When storage for an object with automatic or dynamic storage duration
is obtained,
the bytes comprising the storage for the object
have the following initial value:
\begin{itemize}
\item
If the object has dynamic storage duration, or
is the object associated with a variable or function parameter
whose first declaration is marked with
the \tcode{[[indeterminate]]} attribute\iref{dcl.attr.indet},
the bytes have \emph{indeterminate values};
\item
otherwise, the bytes have \emph{erroneous values},
where each value is determined by the implementation
independently of the state of the program.
\end{itemize}
If no initialization is performed for an object (including subobjects),
such a byte retains its initial value
until that value is replaced\iref{dcl.init.general,expr.ass}.
If any bit in the value representation has an indeterminate value,
the object has an indeterminate value;
otherwise, if any bit in the value representation has an erroneous value,
the object has an erroneous value\iref{conv.lval}.
\begin{note}
Objects with static or thread storage duration are zero-initialized,
see~\iref{basic.start.static}.
\end{note}

%JMB: I don't think we want to try to introduce the assume semantic
%     in this mailing.  If we did, i would change the following slightly
%     to include indeterminate in the new paragraph and take all mention of behaviour
%     out of the following paragraph
%TD: I agree. We don't need the assume semantic here as we wouldn't
%     allow this particular implicit contract assertion to be evaluated with that
%     semantic anyway; you're supposed to use [[indeterminate]] instead.

\begin{addedblock}
The evaluation of any builtin operation includes an implicit postcondition assertion
that it does not produce an erroneous value.  Except in the following cases,
if any operand of a builtin operation is erroneous then the value
produced by that operation is erroneous:
\begin{itemize}
\item [...]
\end{itemize}
\end{addedblock}

Except in the following cases,
if an indeterminate value is produced by an evaluation,
the behavior is undefined
 and if an erroneous value is produced by an evaluation
\removed{, the behavior is erroneous and}
the result of the evaluation is the value so produced \removed{but is not erroneous}
\added{and it is erroneous}:

\begin{itemize}
\item
  If an indeterminate or erroneous value of
  unsigned ordinary character type\iref{basic.fundamental}
  or \tcode{std::byte} type\iref{cstddef.syn}
  is produced by the evaluation of:
  \begin{itemize}
  \item
    the second or third operand of a conditional expression\iref{expr.cond},
  \item
    the right operand of a comma expression\iref{expr.comma},
  \item
    the operand of a cast or conversion\iref{conv.integral,
    expr.type.conv,expr.static.cast,expr.cast}
    to an unsigned ordinary character type
    or \tcode{std::byte} type\iref{cstddef.syn}, or
  \item
    a discarded-value expression\iref{expr.context},
  \end{itemize}
  then the result of the operation is an indeterminate value or
  that erroneous value, respectively.
\item
  If an indeterminate or erroneous value of
  unsigned ordinary character type or \tcode{std::byte} type
  is produced by the evaluation of
  the right operand of a simple assignment operator\iref{expr.ass}
  whose first operand is an lvalue of
  unsigned ordinary character type or \tcode{std::byte} type,
  an indeterminate value or that erroneous value, respectively, replaces
  the value of the object referred to by the left operand.
\item
  If an indeterminate or erroneous value of unsigned ordinary character type
  is produced by the evaluation of the initialization expression
  when initializing an object of unsigned ordinary character type,
  that object is initialized to an indeterminate
  value or that erroneous value, respectively.
\item
  If an indeterminate value of
  unsigned ordinary character type or \tcode{std::byte} type
  is produced by the evaluation of the initialization expression
  when initializing an object of \tcode{std::byte} type,
  that object is initialized to an indeterminate value or
  that erroneous value, respectively.
\end{itemize}
Converting an indeterminate or erroneous value of
unsigned ordinary character type or \tcode{std::byte} type
produces an indeterminate or erroneous value, respectively.
In the latter case,
the result of the conversion is the value of the converted operand.

\begin{addedblock}
Except in the following cases, if an operand of a builtin operator
is an erroneous value then the result of that operation is errroneous:
\begin{itemize}
\item Multiplication where one of the operands is a non-erroneous
  zero value,
%jmb: I can't think of any other needed exceptions - comma and ternary operators are
%  covered by the previous paragraph.
% TD: So it should not be a bullet list at all?
\end{itemize}
\end{addedblock}
\end{adjustwidth}

Modify [expr.const], paragraph 10:

\begin{adjustwidth}{0.5cm}{0.5cm}
An expression $E$ is a \emph{core constant expression} unless the evaluation of $E$, following the rules of the abstract machine ([intro.abstract]), would evaluate one of the following:
\begin{itemize}
\item [...]
\item an operation that would have undefined \removed{or erroneous }behavior as specified in Clause 4 through Clause 15;
\item [...]
\end{itemize}
\end{adjustwidth}

Modify [dcl.attr.indet], paragraph 3:

\begin{adjustwidth}{0.5cm}{0.5cm}
[ \emph{Note:} Reading from an uninitialized variable that is marked \tcode{[[indeterminate]]} can cause undefined behavior.
\begin{adjustwidth}{0.3cm}{0.3cm}
\tcode{void f(int);}\\
\tcode{void g() \{}\\
\codetab \tcode{int x [[indeterminate]], y;}\\
\codetab \tcode{f(y);} \codelongtab \emph{// \removed{erroneous behavior}\added{contract violation} ([basic.indet])}\\
\codetab \tcode{f(y);} \codelongtab \emph{// undefined behavior}\\
\tcode{\}} \\
\\
\tcode{[...]}
\end{adjustwidth}
--- \emph{end note} ]
\end{adjustwidth}

Modify [nullablepointer.requirements], paragraph 2:

\begin{adjustwidth}{0.5cm}{0.5cm}
A value-initialized object of type \tcode{P} produces the null value of the type. The null value shall be equivalent only to itself. A default-initialized object of type \tcode{P} may have an indeterminate or erroneous value.

\emph{Note:} perations involving indeterminate values can cause undefined behavior, and operations involving erroneous values can cause \removed{erroneous behavior}\added{contract violations} ([basic.indet]).--- \emph{end note} ]
\end{adjustwidth}

Modify [bit.cast], paragraph 2:

\begin{adjustwidth}{0.5cm}{0.5cm}
For each bit $b$ in the value representation of the result that is indeterminate or erroneous, let $u$ be the smallest object containing that bit enclosing $b$:
\begin{itemize}
\item  If $u$ is of unsigned ordinary character type or \tcode{std::byte} type, $u$ has an indeterminate value if any of the bits in its value representation are indeterminate, or otherwise has an erroneous value.
\item Otherwise, if $b$ is indeterminate, the behavior is undefined.
\item Otherwise, \removed{the behavior is erroneous}\added{an implicit contract violation ([basic.contract]) occurs}, and the result is as specified above.
\end{itemize}
The result does not otherwise contain any indeterminate or erroneous values.
\end{adjustwidth}

Modify [contracts.syn]:

\begin{adjustwidth}{0.5cm}{0.5cm}
\emph{// all freestanding} \\
\tcode{namespace std::contracts \{} \\
\\
\codetab \tcode{enum class assertion_kind : \emph{unspecified}} \\
\codetab \codetab \added{\tcode{implicit = 1,}} \\
\codetab \codetab \tcode{pre = \removed{1}\added{2},} \\
\codetab \codetab \tcode{post = \removed{2}\added{3},} \\
\codetab \codetab \tcode{assert = \removed{3}\added{4}} \\
\codetab \tcode{\};} \\
\\
\codetab \tcode{[...]} \\ 
\\
\codetab \tcode{enum class detection_mode : \emph{unspecified}} \\
\codetab \codetab \tcode{predicate_false = 1,} \\
\codetab \codetab \tcode{evaluation_exception = 2\added{, }} \\
\codetab \codetab \tcode{\added{erroneous_value = 1}} \\
\codetab \tcode{\};} 
\end{adjustwidth}

Modify [support.contracts.enum.kind]:

\begin{adjustwidth}{0.5cm}{0.5cm}
The enumerators of \tcode{assertion_kind} correspond to the possible syntactic forms of a contract assertion ([basic.contract]):
\begin{itemize}
\item \tcode{\added{assertion_kind::implicit}}\added{: the evaluated contract assertion was an implicit contract assertion.}
\item \tcode{assertion_kind::pre}: the evaluated contract assertion was a\added{n explicit} precondition assertion.
\item \tcode{assertion_kind::post}: the evaluated contract assertion was a\added{n explicit} postcondition assertion.
\item \tcode{assertion_kind::assert}: the evaluated contract assertion was an\added{ explicit} assertion-statement.
\end{itemize}
\end{adjustwidth}

Modify [support.contracts.enum.detection]:

\begin{adjustwidth}{0.5cm}{0.5cm}
The enumerators of \tcode{detection_mode} correspond to the manners in which a contract violation ([basic.contract.eval]) can be identified:
\begin{itemize}
\item \tcode{detection_mode::predicate_false}: the contract violation occurred because the predicate evaluated to \tcode{false} or would have evaluated to \tcode{false}.
\item \tcode{detection_mode::evaluation_exception}: the contract violation occurred because the evaluation of the predicate exited via an exception.
\item \tcode{\added{detection_mode::erroneous_value}}\added{: the contract violation occurred because an erro\-neous value was encountered.}
\end{itemize}
\end{adjustwidth}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section*{Acknowledgements}
% None so far

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Remove ToC entry for bibliography
\renewcommand{\addcontentsline}[3]{}% Make \addcontentsline a no-op to disable auto ToC entry

%\renewcommand{\bibname}{References}  % custom name for bibliography
\bibliographystyle{abstract}
\bibliography{ref}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
